// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/jumata96/pac-ent/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/jumata96/pac-ent/ent/asistencia"
	"github.com/jumata96/pac-ent/ent/cliente"
	"github.com/jumata96/pac-ent/ent/entrenador"
	"github.com/jumata96/pac-ent/ent/membresia"
	"github.com/jumata96/pac-ent/ent/rutina"
	"github.com/jumata96/pac-ent/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Asistencia is the client for interacting with the Asistencia builders.
	Asistencia *AsistenciaClient
	// Cliente is the client for interacting with the Cliente builders.
	Cliente *ClienteClient
	// Entrenador is the client for interacting with the Entrenador builders.
	Entrenador *EntrenadorClient
	// Membresia is the client for interacting with the Membresia builders.
	Membresia *MembresiaClient
	// Rutina is the client for interacting with the Rutina builders.
	Rutina *RutinaClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Asistencia = NewAsistenciaClient(c.config)
	c.Cliente = NewClienteClient(c.config)
	c.Entrenador = NewEntrenadorClient(c.config)
	c.Membresia = NewMembresiaClient(c.config)
	c.Rutina = NewRutinaClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Asistencia: NewAsistenciaClient(cfg),
		Cliente:    NewClienteClient(cfg),
		Entrenador: NewEntrenadorClient(cfg),
		Membresia:  NewMembresiaClient(cfg),
		Rutina:     NewRutinaClient(cfg),
		User:       NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Asistencia: NewAsistenciaClient(cfg),
		Cliente:    NewClienteClient(cfg),
		Entrenador: NewEntrenadorClient(cfg),
		Membresia:  NewMembresiaClient(cfg),
		Rutina:     NewRutinaClient(cfg),
		User:       NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Asistencia.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Asistencia, c.Cliente, c.Entrenador, c.Membresia, c.Rutina, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Asistencia, c.Cliente, c.Entrenador, c.Membresia, c.Rutina, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AsistenciaMutation:
		return c.Asistencia.mutate(ctx, m)
	case *ClienteMutation:
		return c.Cliente.mutate(ctx, m)
	case *EntrenadorMutation:
		return c.Entrenador.mutate(ctx, m)
	case *MembresiaMutation:
		return c.Membresia.mutate(ctx, m)
	case *RutinaMutation:
		return c.Rutina.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AsistenciaClient is a client for the Asistencia schema.
type AsistenciaClient struct {
	config
}

// NewAsistenciaClient returns a client for the Asistencia from the given config.
func NewAsistenciaClient(c config) *AsistenciaClient {
	return &AsistenciaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asistencia.Hooks(f(g(h())))`.
func (c *AsistenciaClient) Use(hooks ...Hook) {
	c.hooks.Asistencia = append(c.hooks.Asistencia, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `asistencia.Intercept(f(g(h())))`.
func (c *AsistenciaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Asistencia = append(c.inters.Asistencia, interceptors...)
}

// Create returns a builder for creating a Asistencia entity.
func (c *AsistenciaClient) Create() *AsistenciaCreate {
	mutation := newAsistenciaMutation(c.config, OpCreate)
	return &AsistenciaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Asistencia entities.
func (c *AsistenciaClient) CreateBulk(builders ...*AsistenciaCreate) *AsistenciaCreateBulk {
	return &AsistenciaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AsistenciaClient) MapCreateBulk(slice any, setFunc func(*AsistenciaCreate, int)) *AsistenciaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AsistenciaCreateBulk{err: fmt.Errorf("calling to AsistenciaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AsistenciaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AsistenciaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Asistencia.
func (c *AsistenciaClient) Update() *AsistenciaUpdate {
	mutation := newAsistenciaMutation(c.config, OpUpdate)
	return &AsistenciaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AsistenciaClient) UpdateOne(a *Asistencia) *AsistenciaUpdateOne {
	mutation := newAsistenciaMutation(c.config, OpUpdateOne, withAsistencia(a))
	return &AsistenciaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AsistenciaClient) UpdateOneID(id int) *AsistenciaUpdateOne {
	mutation := newAsistenciaMutation(c.config, OpUpdateOne, withAsistenciaID(id))
	return &AsistenciaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Asistencia.
func (c *AsistenciaClient) Delete() *AsistenciaDelete {
	mutation := newAsistenciaMutation(c.config, OpDelete)
	return &AsistenciaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AsistenciaClient) DeleteOne(a *Asistencia) *AsistenciaDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AsistenciaClient) DeleteOneID(id int) *AsistenciaDeleteOne {
	builder := c.Delete().Where(asistencia.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AsistenciaDeleteOne{builder}
}

// Query returns a query builder for Asistencia.
func (c *AsistenciaClient) Query() *AsistenciaQuery {
	return &AsistenciaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAsistencia},
		inters: c.Interceptors(),
	}
}

// Get returns a Asistencia entity by its id.
func (c *AsistenciaClient) Get(ctx context.Context, id int) (*Asistencia, error) {
	return c.Query().Where(asistencia.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AsistenciaClient) GetX(ctx context.Context, id int) *Asistencia {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AsistenciaClient) Hooks() []Hook {
	return c.hooks.Asistencia
}

// Interceptors returns the client interceptors.
func (c *AsistenciaClient) Interceptors() []Interceptor {
	return c.inters.Asistencia
}

func (c *AsistenciaClient) mutate(ctx context.Context, m *AsistenciaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AsistenciaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AsistenciaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AsistenciaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AsistenciaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Asistencia mutation op: %q", m.Op())
	}
}

// ClienteClient is a client for the Cliente schema.
type ClienteClient struct {
	config
}

// NewClienteClient returns a client for the Cliente from the given config.
func NewClienteClient(c config) *ClienteClient {
	return &ClienteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cliente.Hooks(f(g(h())))`.
func (c *ClienteClient) Use(hooks ...Hook) {
	c.hooks.Cliente = append(c.hooks.Cliente, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cliente.Intercept(f(g(h())))`.
func (c *ClienteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Cliente = append(c.inters.Cliente, interceptors...)
}

// Create returns a builder for creating a Cliente entity.
func (c *ClienteClient) Create() *ClienteCreate {
	mutation := newClienteMutation(c.config, OpCreate)
	return &ClienteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Cliente entities.
func (c *ClienteClient) CreateBulk(builders ...*ClienteCreate) *ClienteCreateBulk {
	return &ClienteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClienteClient) MapCreateBulk(slice any, setFunc func(*ClienteCreate, int)) *ClienteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClienteCreateBulk{err: fmt.Errorf("calling to ClienteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClienteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClienteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Cliente.
func (c *ClienteClient) Update() *ClienteUpdate {
	mutation := newClienteMutation(c.config, OpUpdate)
	return &ClienteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClienteClient) UpdateOne(cl *Cliente) *ClienteUpdateOne {
	mutation := newClienteMutation(c.config, OpUpdateOne, withCliente(cl))
	return &ClienteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClienteClient) UpdateOneID(id int) *ClienteUpdateOne {
	mutation := newClienteMutation(c.config, OpUpdateOne, withClienteID(id))
	return &ClienteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Cliente.
func (c *ClienteClient) Delete() *ClienteDelete {
	mutation := newClienteMutation(c.config, OpDelete)
	return &ClienteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClienteClient) DeleteOne(cl *Cliente) *ClienteDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClienteClient) DeleteOneID(id int) *ClienteDeleteOne {
	builder := c.Delete().Where(cliente.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClienteDeleteOne{builder}
}

// Query returns a query builder for Cliente.
func (c *ClienteClient) Query() *ClienteQuery {
	return &ClienteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCliente},
		inters: c.Interceptors(),
	}
}

// Get returns a Cliente entity by its id.
func (c *ClienteClient) Get(ctx context.Context, id int) (*Cliente, error) {
	return c.Query().Where(cliente.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClienteClient) GetX(ctx context.Context, id int) *Cliente {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ClienteClient) Hooks() []Hook {
	return c.hooks.Cliente
}

// Interceptors returns the client interceptors.
func (c *ClienteClient) Interceptors() []Interceptor {
	return c.inters.Cliente
}

func (c *ClienteClient) mutate(ctx context.Context, m *ClienteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClienteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClienteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClienteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClienteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Cliente mutation op: %q", m.Op())
	}
}

// EntrenadorClient is a client for the Entrenador schema.
type EntrenadorClient struct {
	config
}

// NewEntrenadorClient returns a client for the Entrenador from the given config.
func NewEntrenadorClient(c config) *EntrenadorClient {
	return &EntrenadorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entrenador.Hooks(f(g(h())))`.
func (c *EntrenadorClient) Use(hooks ...Hook) {
	c.hooks.Entrenador = append(c.hooks.Entrenador, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entrenador.Intercept(f(g(h())))`.
func (c *EntrenadorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entrenador = append(c.inters.Entrenador, interceptors...)
}

// Create returns a builder for creating a Entrenador entity.
func (c *EntrenadorClient) Create() *EntrenadorCreate {
	mutation := newEntrenadorMutation(c.config, OpCreate)
	return &EntrenadorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entrenador entities.
func (c *EntrenadorClient) CreateBulk(builders ...*EntrenadorCreate) *EntrenadorCreateBulk {
	return &EntrenadorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntrenadorClient) MapCreateBulk(slice any, setFunc func(*EntrenadorCreate, int)) *EntrenadorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntrenadorCreateBulk{err: fmt.Errorf("calling to EntrenadorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntrenadorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntrenadorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entrenador.
func (c *EntrenadorClient) Update() *EntrenadorUpdate {
	mutation := newEntrenadorMutation(c.config, OpUpdate)
	return &EntrenadorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntrenadorClient) UpdateOne(e *Entrenador) *EntrenadorUpdateOne {
	mutation := newEntrenadorMutation(c.config, OpUpdateOne, withEntrenador(e))
	return &EntrenadorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntrenadorClient) UpdateOneID(id int) *EntrenadorUpdateOne {
	mutation := newEntrenadorMutation(c.config, OpUpdateOne, withEntrenadorID(id))
	return &EntrenadorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entrenador.
func (c *EntrenadorClient) Delete() *EntrenadorDelete {
	mutation := newEntrenadorMutation(c.config, OpDelete)
	return &EntrenadorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntrenadorClient) DeleteOne(e *Entrenador) *EntrenadorDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntrenadorClient) DeleteOneID(id int) *EntrenadorDeleteOne {
	builder := c.Delete().Where(entrenador.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntrenadorDeleteOne{builder}
}

// Query returns a query builder for Entrenador.
func (c *EntrenadorClient) Query() *EntrenadorQuery {
	return &EntrenadorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntrenador},
		inters: c.Interceptors(),
	}
}

// Get returns a Entrenador entity by its id.
func (c *EntrenadorClient) Get(ctx context.Context, id int) (*Entrenador, error) {
	return c.Query().Where(entrenador.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntrenadorClient) GetX(ctx context.Context, id int) *Entrenador {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntrenadorClient) Hooks() []Hook {
	return c.hooks.Entrenador
}

// Interceptors returns the client interceptors.
func (c *EntrenadorClient) Interceptors() []Interceptor {
	return c.inters.Entrenador
}

func (c *EntrenadorClient) mutate(ctx context.Context, m *EntrenadorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntrenadorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntrenadorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntrenadorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntrenadorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Entrenador mutation op: %q", m.Op())
	}
}

// MembresiaClient is a client for the Membresia schema.
type MembresiaClient struct {
	config
}

// NewMembresiaClient returns a client for the Membresia from the given config.
func NewMembresiaClient(c config) *MembresiaClient {
	return &MembresiaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membresia.Hooks(f(g(h())))`.
func (c *MembresiaClient) Use(hooks ...Hook) {
	c.hooks.Membresia = append(c.hooks.Membresia, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membresia.Intercept(f(g(h())))`.
func (c *MembresiaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Membresia = append(c.inters.Membresia, interceptors...)
}

// Create returns a builder for creating a Membresia entity.
func (c *MembresiaClient) Create() *MembresiaCreate {
	mutation := newMembresiaMutation(c.config, OpCreate)
	return &MembresiaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Membresia entities.
func (c *MembresiaClient) CreateBulk(builders ...*MembresiaCreate) *MembresiaCreateBulk {
	return &MembresiaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MembresiaClient) MapCreateBulk(slice any, setFunc func(*MembresiaCreate, int)) *MembresiaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MembresiaCreateBulk{err: fmt.Errorf("calling to MembresiaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MembresiaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MembresiaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Membresia.
func (c *MembresiaClient) Update() *MembresiaUpdate {
	mutation := newMembresiaMutation(c.config, OpUpdate)
	return &MembresiaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MembresiaClient) UpdateOne(m *Membresia) *MembresiaUpdateOne {
	mutation := newMembresiaMutation(c.config, OpUpdateOne, withMembresia(m))
	return &MembresiaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MembresiaClient) UpdateOneID(id int) *MembresiaUpdateOne {
	mutation := newMembresiaMutation(c.config, OpUpdateOne, withMembresiaID(id))
	return &MembresiaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Membresia.
func (c *MembresiaClient) Delete() *MembresiaDelete {
	mutation := newMembresiaMutation(c.config, OpDelete)
	return &MembresiaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MembresiaClient) DeleteOne(m *Membresia) *MembresiaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MembresiaClient) DeleteOneID(id int) *MembresiaDeleteOne {
	builder := c.Delete().Where(membresia.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MembresiaDeleteOne{builder}
}

// Query returns a query builder for Membresia.
func (c *MembresiaClient) Query() *MembresiaQuery {
	return &MembresiaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMembresia},
		inters: c.Interceptors(),
	}
}

// Get returns a Membresia entity by its id.
func (c *MembresiaClient) Get(ctx context.Context, id int) (*Membresia, error) {
	return c.Query().Where(membresia.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MembresiaClient) GetX(ctx context.Context, id int) *Membresia {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MembresiaClient) Hooks() []Hook {
	return c.hooks.Membresia
}

// Interceptors returns the client interceptors.
func (c *MembresiaClient) Interceptors() []Interceptor {
	return c.inters.Membresia
}

func (c *MembresiaClient) mutate(ctx context.Context, m *MembresiaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MembresiaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MembresiaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MembresiaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MembresiaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Membresia mutation op: %q", m.Op())
	}
}

// RutinaClient is a client for the Rutina schema.
type RutinaClient struct {
	config
}

// NewRutinaClient returns a client for the Rutina from the given config.
func NewRutinaClient(c config) *RutinaClient {
	return &RutinaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rutina.Hooks(f(g(h())))`.
func (c *RutinaClient) Use(hooks ...Hook) {
	c.hooks.Rutina = append(c.hooks.Rutina, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rutina.Intercept(f(g(h())))`.
func (c *RutinaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Rutina = append(c.inters.Rutina, interceptors...)
}

// Create returns a builder for creating a Rutina entity.
func (c *RutinaClient) Create() *RutinaCreate {
	mutation := newRutinaMutation(c.config, OpCreate)
	return &RutinaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Rutina entities.
func (c *RutinaClient) CreateBulk(builders ...*RutinaCreate) *RutinaCreateBulk {
	return &RutinaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RutinaClient) MapCreateBulk(slice any, setFunc func(*RutinaCreate, int)) *RutinaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RutinaCreateBulk{err: fmt.Errorf("calling to RutinaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RutinaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RutinaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Rutina.
func (c *RutinaClient) Update() *RutinaUpdate {
	mutation := newRutinaMutation(c.config, OpUpdate)
	return &RutinaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RutinaClient) UpdateOne(r *Rutina) *RutinaUpdateOne {
	mutation := newRutinaMutation(c.config, OpUpdateOne, withRutina(r))
	return &RutinaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RutinaClient) UpdateOneID(id int) *RutinaUpdateOne {
	mutation := newRutinaMutation(c.config, OpUpdateOne, withRutinaID(id))
	return &RutinaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Rutina.
func (c *RutinaClient) Delete() *RutinaDelete {
	mutation := newRutinaMutation(c.config, OpDelete)
	return &RutinaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RutinaClient) DeleteOne(r *Rutina) *RutinaDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RutinaClient) DeleteOneID(id int) *RutinaDeleteOne {
	builder := c.Delete().Where(rutina.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RutinaDeleteOne{builder}
}

// Query returns a query builder for Rutina.
func (c *RutinaClient) Query() *RutinaQuery {
	return &RutinaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRutina},
		inters: c.Interceptors(),
	}
}

// Get returns a Rutina entity by its id.
func (c *RutinaClient) Get(ctx context.Context, id int) (*Rutina, error) {
	return c.Query().Where(rutina.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RutinaClient) GetX(ctx context.Context, id int) *Rutina {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RutinaClient) Hooks() []Hook {
	return c.hooks.Rutina
}

// Interceptors returns the client interceptors.
func (c *RutinaClient) Interceptors() []Interceptor {
	return c.inters.Rutina
}

func (c *RutinaClient) mutate(ctx context.Context, m *RutinaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RutinaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RutinaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RutinaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RutinaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Rutina mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Asistencia, Cliente, Entrenador, Membresia, Rutina, User []ent.Hook
	}
	inters struct {
		Asistencia, Cliente, Entrenador, Membresia, Rutina, User []ent.Interceptor
	}
)
